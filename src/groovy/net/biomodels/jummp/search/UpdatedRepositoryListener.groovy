package net.biomodels.jummp.search
import org.springframework.context.ApplicationEvent
import org.springframework.context.ApplicationListener
import net.biomodels.jummp.core.events.RevisionCreatedEvent
import net.biomodels.jummp.core.model.RevisionTransportCommand
import net.biomodels.jummp.core.events.ModelCreatedEvent
import org.apache.lucene.store.FSDirectory
import org.apache.lucene.store.Directory
import org.apache.lucene.index.IndexDeletionPolicy
import org.apache.lucene.index.IndexWriter
import org.apache.lucene.index.IndexWriterConfig
import org.apache.lucene.util.Version
import org.apache.lucene.index.IndexWriterConfig.OpenMode
import org.codehaus.groovy.grails.commons.cfg.ConfigurationHelper
import grails.util.Environment
import org.apache.lucene.document.Document
import org.apache.lucene.document.Field
import org.apache.lucene.index.KeepOnlyLastCommitDeletionPolicy
import org.apache.lucene.analysis.standard.StandardAnalyzer
import org.apache.lucene.analysis.Analyzer
import org.apache.lucene.index.IndexWriterConfig
import org.apache.lucene.search.SearcherManager
import org.apache.lucene.search.SearcherFactory
import org.apache.lucene.search.IndexSearcher
import org.codehaus.groovy.grails.commons.ApplicationHolder
import grails.util.Environment
/**
 * @short Listener for new revisions and models for indexing
 *
 * This class is meant to be executed as a (singleton) spring bean
 * which listens for events generated by the model service (new models/new revisions).
 * An indexwriter is kept open (maintaining an exclusive lock on the search index)
 * and new models/revisions are indexed as they arrive. The class is also used to
 * get a searchermanager, utilising the Lucene Near Realtime Search mechanism.
 *
 * @author Raza Ali, raza.ali@ebi.ac.uk
 * @date   9/09/2013
 */
class UpdatedRepositoryListener implements ApplicationListener {

	IndexWriter indexWriter
	def modelDelegateService
	def grailsApplication = ApplicationHolder.application
	
	/**
	* Creates/Opens a lucene index based on the config properties (unless test, 
	* otherwise a default location is used, to avoid corrupting the index). 
	*/
	public UpdatedRepositoryListener() {
		String path=grailsApplication.config.jummp.search.index
		if (Environment.current == Environment.TEST) {
			path = "target/search/index"
			File deleteMe=new File(path)
			deleteMe.deleteDir()
		}
		File location=new File(path)
		location.mkdirs()
		System.out.println("USING ${location} for directory!")
		//Create instance of Directory where index files will be stored
		Directory fsDirectory =  FSDirectory.open(location);
		/* Create instance of analyzer, which will be used to tokenize
		the input data */
		Analyzer standardAnalyzer = new StandardAnalyzer(Version.LUCENE_44);
		//Create the instance of deletion policy
		IndexDeletionPolicy deletionPolicy = new KeepOnlyLastCommitDeletionPolicy(); 
		
		IndexWriterConfig conf=new IndexWriterConfig(Version.LUCENE_44,standardAnalyzer)
		conf.setIndexDeletionPolicy(deletionPolicy)
		conf.setOpenMode(OpenMode.CREATE_OR_APPEND)
		indexWriter =new IndexWriter(fsDirectory,conf);
	}
	
	/**
	* Responds to model creation/update events
	*
	* Responds to the @param event, if it is a model create/update, it is indexed
	* in the lucene index.
	* @param event The event, to be handled if it a model create/update event
	**/
	public void onApplicationEvent(ApplicationEvent event) {
		if (event instanceof RevisionCreatedEvent) {
			updateIndex((event as RevisionCreatedEvent).revision)
		}
		if (event instanceof ModelCreatedEvent) {
			updateIndex(modelDelegateService.
						getLatestRevision((event as ModelCreatedEvent).model.id))
													
		}
	}
	
	/**
	* Adds a revision to the index
	*
	* Adds the specified @param revision to the lucene index
	* @param revision The revision to be indexed
	**/
	public void updateIndex(RevisionTransportCommand revision) {
		
		String name = revision.name
		String description = revision.description
		String content=modelDelegateService.getSearchIndexingContent(revision)
		Document doc = new Document();
		
		/*
		*	Indexed fields
		*/
		Field nameField =
			new Field("name",name,Field.Store.YES,Field.Index.ANALYZED);
		Field descriptionField = 
			new Field("description",description,Field.Store.NO,Field.Index.ANALYZED); 
		Field formatField = 
			new Field("format",""+revision.format.name,Field.Store.YES,Field.Index.NOT_ANALYZED);
		Field contentField = 
			new Field("content",content,Field.Store.NO,Field.Index.ANALYZED); 
		
		doc.add(nameField);
		doc.add(descriptionField);
		doc.add(formatField)
		doc.add(contentField)
			
			
		/*
		*	Stored fields. Hopefully will be used to display the search results one day
		*	instead of going to the database for each model. When we find a solution to needing to
		*	look in the database to figure out if the user has access to a model. 
		*/
		Field idField = 
			new Field("model_id",""+revision.model.id,Field.Store.YES,Field.Index.NO); 
		Field versionField = 
			new Field("versionNumber",""+revision.revisionNumber,Field.Store.YES,Field.Index.NO);
		Field submittedField = 
			new Field("submissionDate",""+revision.model.submissionDate,Field.Store.YES,Field.Index.NO);
		Field submitterField = 
			new Field("submitter",""+revision.model.submitter,Field.Store.YES,Field.Index.NOT_ANALYZED);
		doc.add(idField);
		doc.add(versionField);
		doc.add(submittedField)
		doc.add(submitterField)
		
		indexWriter.addDocument(doc);
		indexWriter.commit(); // To do: investigate a more optimised commit mechanism
	}
	
	/**
	* Gets a searchermanager linked to the indexwriter
	*
	* @returns A searchermanager linked to the indexwriter, so that changes made in the writer will be
	* reflected in the searcher.
	**/
	public SearcherManager getSearcherManager() {
		boolean applyAllDeletes = true;
		SearcherManager mgr = new SearcherManager(indexWriter, true, new SearcherFactory());
                return mgr
	}
	
	
}
