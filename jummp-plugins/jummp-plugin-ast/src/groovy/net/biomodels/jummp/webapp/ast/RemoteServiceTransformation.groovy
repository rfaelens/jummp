package net.biomodels.jummp.webapp.ast

import groovyjarjarasm.asm.Opcodes
import org.codehaus.groovy.ast.AnnotationNode
import org.codehaus.groovy.ast.ASTNode
import org.codehaus.groovy.ast.ClassNode
import org.codehaus.groovy.ast.MethodNode
import org.codehaus.groovy.ast.expr.ArgumentListExpression
import org.codehaus.groovy.ast.expr.ConstantExpression
import org.codehaus.groovy.ast.expr.MethodCallExpression
import org.codehaus.groovy.ast.expr.VariableExpression
import org.codehaus.groovy.ast.stmt.ExpressionStatement
import org.codehaus.groovy.ast.stmt.ReturnStatement
import org.codehaus.groovy.control.CompilePhase
import org.codehaus.groovy.control.SourceUnit
import org.codehaus.groovy.transform.GroovyASTTransformation
import org.codehaus.groovy.transform.ASTTransformation

/**
 * @short AST Transformation to generate code for delegating Remote*Service.
 *
 * This class provides the AST Transformation (http://groovy.codehaus.org/Compile-time+Metaprogramming+-+AST+Transformations)
 * to implement all the delegating methods in Remote*Services. A method in a Remote*Service implements an interface and
 * delegates all methods just to an instance of the same service. E.g.
 *
 * @code
 * class RemoteFooService implements RemoteFooAdapter {
 *     RemoteFooAdapter remoteFooAdapter
 *
 *     Bar getFooBar(Foo parameter1, Baz parameter2) {
 *         return remoteFooAdapter.getFooBar(parameter1, parameter2)
 *     }
 * }
 * @endcode
 *
 * The code for all such methods is generated by this transformation, removing the need to implement the code in
 * the actual implementation.
 *
 * As the transformation is injected in the compile phase the resulting code will compile and the Service functions
 * as expected.
 *
 * The transformation is triggered by the annotation @link RemoteService which takes the name of the Interface as a
 * value.
 * @see RemoteService
 * @author Martin Gräßlin <m.graesslin@dkfz.de>
 */
@GroovyASTTransformation(phase = CompilePhase.SEMANTIC_ANALYSIS)
class RemoteServiceTransformation implements ASTTransformation {

    void visit(ASTNode[] astNodes, SourceUnit sourceUnit) {
        // The name of the interface whose methods needs to be implemented, is the value of the Annotation triggering the AST transformation
        AnnotationNode annotationNode = (AnnotationNode)astNodes[0]
        String interfaceName = annotationNode.getMember("value").getValue()
        // the class has a field with the same name as the interface, but starting with lower case
        String serviceName = interfaceName.substring(0, 1).toLowerCase() + interfaceName.substring(1)
        ClassNode classNode = ((ClassNode)astNodes[1])

        // search for the interface matching our annotation value
        ClassNode serviceInterface = null
        classNode.getInterfaces().each {
            if (it.getNameWithoutPackage() == interfaceName) {
                serviceInterface = it
            }
        }
        if (!serviceInterface) {
            // we did not find our interface, so return
            return
        }
        // generate all the methods of the interface
        serviceInterface.getMethods().each {
            // the methods arguments become parameters
            List arguments = []
            it.parameters.each { parameter ->
                arguments << new VariableExpression(parameter.name)
            }
            // the delegated method call: ${serviceName}.${it.name}(${arguments})
            MethodCallExpression delegatedMethodCall = new MethodCallExpression(new VariableExpression(serviceName), it.name, new ArgumentListExpression(arguments))
            // the complete method: same name, same return type, same parameters, same exceptions and either just a method call (return type void) or a return statement
            MethodNode method = new MethodNode(
                    it.name, Opcodes.ACC_PUBLIC, it.returnType, it.parameters, it.exceptions,
                    (it.returnType.typeClass == Void.TYPE) ? new ExpressionStatement(delegatedMethodCall) : new ReturnStatement(delegatedMethodCall)
            )
            // add Profiled annotation to method. Annotation has a "tag" with String value: className.methodName
            // looks like: @Profiled(tag="${classNode.getNameWithoutPackage()}.${it.name}")
            AnnotationNode profiled = new AnnotationNode(new ClassNode(this.getClass().classLoader.loadClass("org.perf4j.aop.Profiled")))
            profiled.addMember("tag", new ConstantExpression(classNode.getNameWithoutPackage() + "." + it.name))
            method.addAnnotation(profiled)
            // and finally add the method to our class
            classNode.addMethod(method)
        }
    }
}
